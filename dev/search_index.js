var documenterSearchIndex = {"docs":
[{"location":"design/#Design","page":"Design","title":"Design","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"The goal of OhMyArtifacts is to provide a caching api that entries can be added/removed during runtime.  The cache is read-only and shared accross packages, that means there won't be any duplicated cache if  they are all using OhMyArtifacts. The cache should also track the usage, so when no package is using that  cache, it will be recycled automatically. The ownership of each cache should be able to delegate to the  downstream package, so that when that package is removed, the cache can be freed.","category":"page"},{"location":"design/#Comparison-to-builtin-Artifact-system-(Artifacts.jl)","page":"Design","title":"Comparison to builtin Artifact system (Artifacts.jl)","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"We already have a stdlib Artifacts.jl in Julia, Why would you need another one? The main reason is,  the builtin artifacts system requires all artifacts to be known before runtime. The Artifact.toml is placed  at the folder of that package, but since the package folder is read-only now, you cannot modify the  Artifact.toml when you use the package. On the other hand, the cache of Artifacts.jl is based on directory  tree hash, so even if there are multiple duplicate files in different diectory, they cannot share the cache.","category":"page"},{"location":"design/#Comparison-to-Scratch-Space-API-(Scratch.jl)","page":"Design","title":"Comparison to Scratch Space API (Scratch.jl)","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"We are actually building on top of Scratch.jl. Scratch.jl provide a set of api for creating package-specific  folder to store any kind of runtime data. In the Scratch.jl README, they also mention that you can  turn the scratch space into artifact. So precisely OhMyArtifacts is an implementation of that idea,  but with some modification to the artifact caching behavior. Notice that our implementation is parallel to  the builtin artifact system (Artifacts.jl), so generally it won't affect each other.","category":"page"},{"location":"design/#How-(v0.3)","page":"Design","title":"How (v0.3)","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"We mentioned a few features and issues that we want to solve, but how does it work? General speaking,  we place all the artifacts in the scratch space of OhMyArtifacts. The directory  structure would look like this:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"OhMyArtifacts-scratchspace/\n  |- logs/\n    |- my_artifact_usage.toml\n    |- my_artifact_orphanages.toml\n  |- artifacts/\n\t|_ <1-byte-prefix>/\n\t  |- <some sha256 string> (either file or directory)\n\t...\n  |- Package-A-scratchspace/\n\t|- Artifacts.toml\n  |- Package-B-scratchspace/\n  |- ...\n  ...","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"The artifacts folder contains all the cache. Each cache is a read-only file or directory whose name is its content (or tree) sha256 hash. The cache is sorted and put in a directory with the name of it's first byte. For example, a sha256 string \"0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f20\" would be put in artifacts/01/.\nmy_artifact_usage.toml is a log file, which track all the usage of each cache. Can be seemed as a dictionary mapping from cache to a list of Artifacts.toml that use that cache. We use this to know whether a cache can be recycled without causing problems.\nmy_artifact_orphanages.toml is a log file, which track the time that we find a cache is not used by any Artifacts.toml any more. So when the recycle mechanism happened, it will check whether the cache is not used for a given period of time, then recycle it if it exceeds the range.\nFor each package that use OhMyArtifacts, we create another scratch space for it in our scratch space. When the package is removed, this scratch space might also be recycled, so we would know that the usage/orphanages toml will need to be updated. This depends on the recycle mechanism of Scratch.jl.\nThe Artifacts.toml in the scratchspace is the entry point of the OhMyArtifacts api. When caching a file, the api would create a mapping in the Artifacts.toml which map from a name to a sha256 hash. So when loading the file, the path is just the path of artifacts folder with the a prefix and the hash.\nArtifacts.toml has two kinds of entry, isdir = true and isdir = false. When isdir = true, the sha256 hash is the tree hash of the entire directory. The directory structure is copied in artifacts with the  tree hash as folder name. For every file in the folder, the usage is recorded and marked by that folder entry, so whenever the binding of that folder is removed, the usage for every file can be correctly updated. Every non-folder file in copied folder is a symbolic link points to the real file cache in artifacts. The tree hash is computed on the original folder, not the copied folder (because copied folder only contains symbolic links).","category":"page"},{"location":"design/#Internal-(v0.3)","page":"Design","title":"Internal (v0.3)","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"Most of the behaviors are documented in the comment of source code.","category":"page"},{"location":"design/#Files","page":"Design","title":"Files","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"Artifacts.toml: Dict{BindingName => SHA256ContentHash}\nmy_artifact_usage.toml: Dict{CachePath => Dict{ArtifactTomlPath => Dict{BindingName => UsageTime}}}\nmy_artifact_orphanages.toml: Dict{OrphanCachePath => FoundTime}","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = OhMyArtifacts","category":"page"},{"location":"#OhMyArtifacts","page":"Home","title":"OhMyArtifacts","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for OhMyArtifacts.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [OhMyArtifacts]","category":"page"},{"location":"#OhMyArtifacts.bind_my_artifact!-Tuple{String, AbstractString, OhMyArtifacts.SHA256}","page":"Home","title":"OhMyArtifacts.bind_my_artifact!","text":"bind_my_artifact!(artifacts_toml::String, name::AbstractString, hash::SHA256; force::Bool = false)\n\nWrites a mapping of name -> hash in the given \"Artifacts.toml\" file and track the usage. If force  is set to true, this will overwrite a pre-existant mapping, otherwise an error is raised.\n\n\n\n\n\n","category":"method"},{"location":"#OhMyArtifacts.create_my_artifact-Tuple{Function}","page":"Home","title":"OhMyArtifacts.create_my_artifact","text":"create_my_artifact(f::Function)\n\nCreate artifact by calling f(working_dir). f is the function that create/put/download file(s) into  the working_dir. f should either return the path to the file/directory or return nothing. If f  return nothing, then everything in working_dir would be cached. If f return a path, that path  must be inside working_dir.\n\n\n\n\n\n","category":"method"},{"location":"#OhMyArtifacts.download_my_artifact!-Tuple{Function, Any, AbstractString, String}","page":"Home","title":"OhMyArtifacts.download_my_artifact!","text":"download_my_artifact!([downloadf::Function = Downloads.download], url, name::AbstractString, artifacts_toml::String;\n                     force_bind::Bool = false, downloadf_kwarg...)\n\nConvenient function that do download-create-bind together and return the content hash.  Download function downloadf should take two position arguments  (i.e. downloadf(url, dest; downloadf_kwarg...)). if force_bind is true,  it will overwrite the pre-existant binding.\n\nSee also: createmyartifact, bindmyartifact!\n\n\n\n\n\n","category":"method"},{"location":"#OhMyArtifacts.init-Tuple{}","page":"Home","title":"OhMyArtifacts.init","text":"init()\n\nInitialize the storage space.\n\nGenerally you don't have to manually call this function. It would be called everytime you  call my_artifacts_toml!. This function would setup the scratch space we need, check if  we need to recycle some storages.\n\n\n\n\n\n","category":"method"},{"location":"#OhMyArtifacts.load_my_artifacts_toml-Tuple{String}","page":"Home","title":"OhMyArtifacts.load_my_artifacts_toml","text":"load_my_artifacts_toml(artifacts_toml::String)\n\nSafely read the artifacts_toml, return a Dict{String, Any} of binding name to sha256 hash.\n\n\n\n\n\n","category":"method"},{"location":"#OhMyArtifacts.my_artifact_exists-Tuple{OhMyArtifacts.SHA256}","page":"Home","title":"OhMyArtifacts.my_artifact_exists","text":"my_artifact_exists(hash::SHA256)\n\nReturns whether the given artifact (identified by its SHA256 content hash) exists on-disk.\n\n\n\n\n\n","category":"method"},{"location":"#OhMyArtifacts.my_artifact_hash-Tuple{AbstractString, String}","page":"Home","title":"OhMyArtifacts.my_artifact_hash","text":"my_artifact_hash(name::AbstractString, artifacts_toml::String)\n\nReturn the hash found in artifacts_toml with given name, or nothing if not found.\n\n\n\n\n\n","category":"method"},{"location":"#OhMyArtifacts.my_artifact_path-Tuple{OhMyArtifacts.SHA256}","page":"Home","title":"OhMyArtifacts.my_artifact_path","text":"my_artifact_path(hash::SHA256)\n\nGiven an artifact (identified by SHA256 content hash), return its installation path. If the artifact does not exist,  returns the location it would be installed to.\n\nSee also: my_artifact_exists\n\n\n\n\n\n","category":"method"},{"location":"#OhMyArtifacts.my_artifacts_toml!-Tuple{Union{Nothing, Base.UUID, Module}}","page":"Home","title":"OhMyArtifacts.my_artifacts_toml!","text":"my_artifacts_toml!(pkg::Union{Module,Base.UUID,Nothing})\n\nReturn the path to (or creates) \"Artifacts.toml\" for the given pkg.\n\nSee also: @my_artifacts_toml!\n\n\n\n\n\n","category":"method"},{"location":"#OhMyArtifacts.unbind_my_artifact!-Tuple{String, AbstractString}","page":"Home","title":"OhMyArtifacts.unbind_my_artifact!","text":"unbind_my_artifact!(artifacts_toml::String, name::AbstractString)\n\nUnbind the given name from the \"Artifacts.toml\" file. Silently fails if no such binding exists within the file.\n\n\n\n\n\n","category":"method"},{"location":"#OhMyArtifacts.@my_artifact-Tuple{Any, Any, Vararg{Any}}","page":"Home","title":"OhMyArtifacts.@my_artifact","text":"@my_artifact op name [hash]\n\nConvenient macro for working with \"Artifacts.toml\". Requiring a global variable my_artifacts storing the path  to \"Artifacts.toml\" (created by @my_artifacts_toml!) to work correctly.\n\nUsage:\n\n@my_artifact :bind name hash => bind_my_artifact!(my_artifacts, name, hash)\n@my_artifact :hash name => my_artifact_hash(name, my_artifacts)\n@my_artifact :unbind name => unbind_my_artifact!(my_artifacts, name)\n@my_artifact :download name url downloadf kwarg... =>  download_my_artifact!(downloadf, url, name, my_artifacts; kwarg...)\n\nSee also: bind_my_artifact!, my_artifact_hash,  unbind_my_artifact!, @my_artifacts_toml\n\n\n\n\n\n","category":"macro"},{"location":"#OhMyArtifacts.@my_artifacts_toml!-Tuple{}","page":"Home","title":"OhMyArtifacts.@my_artifacts_toml!","text":"@my_artifacts_toml!()\n\nConvenience macro that gets/creates a \"Artifacts.toml\" and parented to the package the calling module belongs to.\n\nSee also: my_artifacts_toml!\n\n\n\n\n\n","category":"macro"}]
}
