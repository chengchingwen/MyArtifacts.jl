var documenterSearchIndex = {"docs":
[{"location":"design/#Design","page":"Design","title":"Design","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"The goal of OhMyArtifacts is to provide a file caching api that entries can be added/removed during runtime.  The cache is read-only and shared accross packages, that means there won't be any duplicated cache if  they are all using OhMyArtifacts. The cache should also track the usage, so when no package is using that  cache, it will be recycled automatically. The ownership of each cache should be able to delegate to the  downstream package, so that when that package is removed, the cache can be freed.","category":"page"},{"location":"design/#Comparison-to-builtin-Artifact-system-(Artifacts.jl)","page":"Design","title":"Comparison to builtin Artifact system (Artifacts.jl)","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"We already have a stdlib Artifacts.jl in Julia, Why would you need another one? The main reason is,  the builtin artifacts system requires all artifacts to be known before runtime. The Artifact.toml is placed  at the folder of that package, but since the package folder is read-only now, you cannot modify the  Artifact.toml when you use the package. On the other hand, the cache of Artifacts.jl is based on directory  tree hash, so even if there are multiple duplicate files in different diectory, they cannot share the cache.","category":"page"},{"location":"design/#Comparison-to-Scratch-Space-API-(Scratch.jl)","page":"Design","title":"Comparison to Scratch Space API (Scratch.jl)","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"We are actually building on top of Scratch.jl. Scratch.jl provide a set of api for creating package-specific  folder to store any kind of runtime data. In the Scratch.jl README, they also mention that you can  turn the scratch space into artifact. So precisely OhMyArtifacts is an implementation of that idea,  but with some modification to the artifact caching behavior. Notice that our implementation is parallel to  the builtin artifact system (Artifacts.jl), so generally it won't affect each other.","category":"page"},{"location":"design/#How-(v0.2)","page":"Design","title":"How (v0.2)","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"We mentioned a few features and issues that we want to solve, but how does it work? General speaking,  we place all the artifacts in the scratch space of OhMyArtifacts. The directory  structure would look like this:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"OhMyArtifacts-scratchspace/\n  |- artifacts/\n\t|- <some sha256 string>\n\t...\n  |- my_artifact_usage.toml\n  |- my_artifact_orphanages.toml\n  |- Package-A-scratchspace/\n\t|- Artifacts.toml\n  |- Package-B-scratchspace/\n  |- ...\n  ...","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"The artifacts folder contains all the cache. Each cache is a read-only file whose name is its","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"content sha256 hash.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"my_artifact_usage.toml is a log file, which track all the usage of each cache. Can be seemed as","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"a dictionary mapping from cache to a list of Artifacts.toml that use that cache. We use this to know  whether a cache can be recycled without causing problems.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"my_artifact_orphanages.toml is a log file, which track the time that we find a cache is not used","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"by any Artifacts.toml any more. So when the recycle mechanism happened, it will check whether the cache  is not used for a given period of time, then recycle it if it exceeds the range.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"For each package that use OhMyArtifacts, we create another scratch space for it in our scratch space.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"When the package is removed, this scratch space might also be recycled, so we would know that the  usage/orphanages toml will need to be updated. This depends on the recycle mechanism of Scratch.jl.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"The Artifacts.toml in the scratchspace is the entry point of the OhMyArtifacts api. When caching","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"a file, the api would create a mapping in the Artifacts.toml which map from a name to a sha256 hash.  So when loading the file, the path is just the path of artifacts folder with the hash.","category":"page"},{"location":"design/#Internal-(v0.2)","page":"Design","title":"Internal (v0.2)","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"Most of the behaviors are documented in the comment of source code.","category":"page"},{"location":"design/#Files","page":"Design","title":"Files","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"Artifacts.toml: Dict{BindingName => SHA256ContentHash}\nmy_artifact_usage.toml: Dict{CachePath => Dict{ArtifactTomlPath => Dict{BindingName => UsageTime}}}\nmy_artifact_orphanages.toml: Dict{OrphanCachePath => FoundTime}","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = OhMyArtifacts","category":"page"},{"location":"#OhMyArtifacts","page":"Home","title":"OhMyArtifacts","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for OhMyArtifacts.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [OhMyArtifacts]","category":"page"},{"location":"#OhMyArtifacts.bind_my_artifact!-Tuple{String, AbstractString, OhMyArtifacts.SHA256}","page":"Home","title":"OhMyArtifacts.bind_my_artifact!","text":"bind_my_artifact!(artifacts_toml::String, name::AbstractString, hash::SHA256; force::Bool = false)\n\nWrites a mapping of name -> hash within the given \"Artifacts.toml\" file. If force is set to true,  this will overwrite a pre-existant mapping, otherwise an error is raised.\n\n\n\n\n\n","category":"method"},{"location":"#OhMyArtifacts.create_my_artifact-Tuple{Function}","page":"Home","title":"OhMyArtifacts.create_my_artifact","text":"create_my_artifact(f::Function)\n\nCreates a new artifact by doing path = f(working_dir), hashing the returned path, and moving it to  the artifact store. Returns the identifying hash of this artifact.\n\nf(working_dir) should return an absolute path to a single file at the top level of working_dir.\n\n\n\n\n\n","category":"method"},{"location":"#OhMyArtifacts.download_my_artifact!-Tuple{Function, Any, AbstractString, String}","page":"Home","title":"OhMyArtifacts.download_my_artifact!","text":"download_my_artifact!([downloadf::Function = Base.download], url, name::AbstractString, artifacts_toml::String;\n                     force_bind::Bool = false, downloadf_kwarg...)\n\nConvenient function that do download-create-bind together and return the content hash.  Download function downloadf should take two position arguments  (i.e. downloadf(url, dest; downloadf_kwarg...)). if force_bind is true,  it will overwrite the pre-existant binding.\n\nSee also: createmyartifact, bindmyartifact!\n\n\n\n\n\n","category":"method"},{"location":"#OhMyArtifacts.my_artifact_exists-Tuple{OhMyArtifacts.SHA256}","page":"Home","title":"OhMyArtifacts.my_artifact_exists","text":"my_artifact_exists(hash::SHA256)\n\nReturns whether the given artifact (identified by its SHA256 content hash) exists on-disk.\n\n\n\n\n\n","category":"method"},{"location":"#OhMyArtifacts.my_artifact_hash-Tuple{AbstractString, String}","page":"Home","title":"OhMyArtifacts.my_artifact_hash","text":"my_artifact_hash(name::AbstractString, artifacts_toml::String)\n\nReturn the hash found in artifacts_toml with given name, or nothing if not found.\n\n\n\n\n\n","category":"method"},{"location":"#OhMyArtifacts.my_artifact_path-Tuple{OhMyArtifacts.SHA256}","page":"Home","title":"OhMyArtifacts.my_artifact_path","text":"my_artifact_path(hash::SHA256)\n\nGiven an artifact (identified by SHA256 content hash), return its installation path. If the artifact does not exist,  returns the location it would be installed to.\n\nSee also: my_artifact_exists\n\n\n\n\n\n","category":"method"},{"location":"#OhMyArtifacts.my_artifacts_toml!-Tuple{Union{Nothing, Base.UUID, Module}}","page":"Home","title":"OhMyArtifacts.my_artifacts_toml!","text":"my_artifacts_toml!(pkg::Union{Module,Base.UUID,Nothing})\n\nReturn the path to (or creates) \"Artifacts.toml\" for the given pkg.\n\nSee also: @my_artifacts_toml!\n\n\n\n\n\n","category":"method"},{"location":"#OhMyArtifacts.unbind_my_artifact!-Tuple{String, AbstractString}","page":"Home","title":"OhMyArtifacts.unbind_my_artifact!","text":"unbind_my_artifact!(artifacts_toml::String, name::AbstractString)\n\nUnbind the given name from the \"Artifacts.toml\" file. Silently fails if no such binding exists within the file.\n\n\n\n\n\n","category":"method"},{"location":"#OhMyArtifacts.@my_artifact-Tuple{Any, Any, Vararg{Any}}","page":"Home","title":"OhMyArtifacts.@my_artifact","text":"@my_artifact op name [hash]\n\nConvenient macro for working with \"Artifacts.toml\". Requiring a global variable my_artifacts storing the path  to \"Artifacts.toml\" (created by @my_artifacts_toml!) to work correctly.\n\nUsage:\n\n@my_artifact :bind name hash => bind_my_artifact!(my_artifacts, name, hash)\n@my_artifact :hash name => my_artifact_hash(name, my_artifacts)\n@my_artifact :unbind name => unbind_my_artifact!(my_artifacts, name)\n@my_artifact :download name url downloadf kwarg... =>  download_my_artifact!(downloadf, url, name, my_artifacts; kwarg...)\n\nSee also: bind_my_artifact!, my_artifact_hash,  unbind_my_artifact!, @my_artifacts_toml\n\n\n\n\n\n","category":"macro"},{"location":"#OhMyArtifacts.@my_artifacts_toml!-Tuple{}","page":"Home","title":"OhMyArtifacts.@my_artifacts_toml!","text":"@my_artifacts_toml!()\n\nConvenience macro that gets/creates a \"Artifacts.toml\" and parented to the package the calling module belongs to.\n\nSee also: my_artifacts_toml!\n\n\n\n\n\n","category":"macro"}]
}
